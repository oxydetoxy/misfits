{"ast":null,"code":"var _jsxFileName = \"/Users/Ishuu/Desktop/cursor/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [visibleLetters, setVisibleLetters] = useState([]);\n  const [flickerIntensity, setFlickerIntensity] = useState(0);\n  const [currentLetterIndex, setCurrentLetterIndex] = useState(0);\n  const [isStarted, setIsStarted] = useState(false);\n  const [letterSharpness, setLetterSharpness] = useState({});\n  const [startTime, setStartTime] = useState(null);\n  const [flickerDecay, setFlickerDecay] = useState(1);\n  const [flickerInterval, setFlickerInterval] = useState(null);\n  const word = \"MISFITS\";\n  const neonColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ff0080', '#00ff80'];\n  useEffect(() => {\n    // Start the effect after a short delay\n    const startTimer = setTimeout(() => {\n      setIsStarted(true);\n      setVisibleLetters([]);\n      setCurrentLetterIndex(0);\n      setLetterSharpness({});\n      setStartTime(Date.now());\n      setFlickerDecay(1);\n    }, 1500);\n    return () => clearTimeout(startTimer);\n  }, []);\n  useEffect(() => {\n    if (!isStarted || currentLetterIndex >= word.length) return;\n\n    // Show each letter one by one\n    const letterTimer = setTimeout(() => {\n      setVisibleLetters(prev => [...prev, currentLetterIndex]);\n      setCurrentLetterIndex(prev => prev + 1);\n    }, 300);\n    return () => clearTimeout(letterTimer);\n  }, [currentLetterIndex, word.length, isStarted]);\n\n  // Main transition effect - controls both flicker decay and letter sharpening\n  useEffect(() => {\n    if (visibleLetters.length === 0 || !startTime) return;\n    const transitionInterval = setInterval(() => {\n      const elapsed = (Date.now() - startTime) / 1000;\n      const totalDuration = 12; // 12 seconds for the full effect\n\n      if (elapsed >= totalDuration) {\n        // Stop everything\n        setFlickerDecay(0);\n        setLetterSharpness(prev => {\n          const newSharpness = {\n            ...prev\n          };\n          visibleLetters.forEach(letterIndex => {\n            newSharpness[letterIndex] = 1;\n          });\n          return newSharpness;\n        });\n        clearInterval(transitionInterval);\n      } else {\n        // Calculate progress\n        const progress = elapsed / totalDuration;\n\n        // Flicker decay: linear from 1 to 0\n        const newFlickerDecay = Math.max(0, 1 - progress);\n        setFlickerDecay(newFlickerDecay);\n\n        // Letter sharpness: gradually increase\n        setLetterSharpness(prev => {\n          const newSharpness = {\n            ...prev\n          };\n          visibleLetters.forEach(letterIndex => {\n            if (!newSharpness[letterIndex]) {\n              newSharpness[letterIndex] = 0;\n            }\n            newSharpness[letterIndex] = Math.min(1, newSharpness[letterIndex] + 0.02);\n          });\n          return newSharpness;\n        });\n      }\n    }, 100);\n    return () => clearInterval(transitionInterval);\n  }, [visibleLetters, startTime]);\n\n  // Flicker effect with dynamic timing\n  useEffect(() => {\n    if (visibleLetters.length === 0) return;\n\n    // Clear existing interval\n    if (flickerInterval) {\n      clearInterval(flickerInterval);\n    }\n\n    // Create new flicker interval with dynamic timing\n    const createFlickerInterval = () => {\n      const baseInterval = 50; // Base flicker speed\n      const slowInterval = 500; // Slow flicker speed\n      const currentInterval = baseInterval + (1 - flickerDecay) * (slowInterval - baseInterval);\n      const newInterval = setInterval(() => {\n        if (flickerDecay <= 0) {\n          setFlickerIntensity(1); // Stable when no flicker\n        } else {\n          const baseFlicker = Math.random() * 0.5 + 0.5;\n          const adjustedFlicker = baseFlicker * flickerDecay;\n          setFlickerIntensity(adjustedFlicker);\n        }\n      }, currentInterval);\n      setFlickerInterval(newInterval);\n    };\n    createFlickerInterval();\n    return () => {\n      if (flickerInterval) {\n        clearInterval(flickerInterval);\n      }\n    };\n  }, [visibleLetters.length, flickerDecay]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"misfits-text\",\n      children: word.split('').map((letter, index) => {\n        const isVisible = visibleLetters.includes(index);\n        const sharpness = letterSharpness[index] || 0;\n        const blurAmount = isVisible ? (1 - sharpness) * 25 : 25;\n        const opacity = isVisible ? 0.4 + sharpness * 0.6 : 0;\n        const brightness = isVisible ? 0.4 + sharpness * 0.6 : 0.4;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: `letter ${isVisible ? 'visible' : ''}`,\n          style: {\n            opacity: opacity,\n            color: neonColors[index % neonColors.length],\n            textShadow: isVisible ? `0 0 10px ${neonColors[index % neonColors.length]}, 0 0 20px ${neonColors[index % neonColors.length]}, 0 0 30px ${neonColors[index % neonColors.length]}, 0 0 40px ${neonColors[index % neonColors.length]}` : 'none',\n            transform: isVisible ? `scale(${1 + (flickerIntensity - 0.7) * 0.03}) translateY(${(flickerIntensity - 0.7) * 1}px)` : 'scale(0.9) translateY(10px)',\n            filter: `blur(${blurAmount}px) brightness(${brightness})`,\n            transition: 'all 0.3s ease-out'\n          },\n          children: letter\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 135,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 126,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 125,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"GSseIc+SL9OVXkrM/hnnAH+tS/g=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","jsxDEV","_jsxDEV","App","_s","visibleLetters","setVisibleLetters","flickerIntensity","setFlickerIntensity","currentLetterIndex","setCurrentLetterIndex","isStarted","setIsStarted","letterSharpness","setLetterSharpness","startTime","setStartTime","flickerDecay","setFlickerDecay","flickerInterval","setFlickerInterval","word","neonColors","startTimer","setTimeout","Date","now","clearTimeout","length","letterTimer","prev","transitionInterval","setInterval","elapsed","totalDuration","newSharpness","forEach","letterIndex","clearInterval","progress","newFlickerDecay","Math","max","min","createFlickerInterval","baseInterval","slowInterval","currentInterval","newInterval","baseFlicker","random","adjustedFlicker","className","children","split","map","letter","index","isVisible","includes","sharpness","blurAmount","opacity","brightness","style","color","textShadow","transform","filter","transition","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/Ishuu/Desktop/cursor/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport './App.css';\n\nfunction App() {\n  const [visibleLetters, setVisibleLetters] = useState([]);\n  const [flickerIntensity, setFlickerIntensity] = useState(0);\n  const [currentLetterIndex, setCurrentLetterIndex] = useState(0);\n  const [isStarted, setIsStarted] = useState(false);\n  const [letterSharpness, setLetterSharpness] = useState({});\n  const [startTime, setStartTime] = useState(null);\n  const [flickerDecay, setFlickerDecay] = useState(1);\n  const [flickerInterval, setFlickerInterval] = useState(null);\n\n  const word = \"MISFITS\";\n  const neonColors = ['#ff0080', '#00ff80', '#0080ff', '#ff8000', '#8000ff', '#ff0080', '#00ff80'];\n\n  useEffect(() => {\n    // Start the effect after a short delay\n    const startTimer = setTimeout(() => {\n      setIsStarted(true);\n      setVisibleLetters([]);\n      setCurrentLetterIndex(0);\n      setLetterSharpness({});\n      setStartTime(Date.now());\n      setFlickerDecay(1);\n    }, 1500);\n\n    return () => clearTimeout(startTimer);\n  }, []);\n\n  useEffect(() => {\n    if (!isStarted || currentLetterIndex >= word.length) return;\n\n    // Show each letter one by one\n    const letterTimer = setTimeout(() => {\n      setVisibleLetters(prev => [...prev, currentLetterIndex]);\n      setCurrentLetterIndex(prev => prev + 1);\n    }, 300);\n\n    return () => clearTimeout(letterTimer);\n  }, [currentLetterIndex, word.length, isStarted]);\n\n  // Main transition effect - controls both flicker decay and letter sharpening\n  useEffect(() => {\n    if (visibleLetters.length === 0 || !startTime) return;\n\n    const transitionInterval = setInterval(() => {\n      const elapsed = (Date.now() - startTime) / 1000;\n      const totalDuration = 12; // 12 seconds for the full effect\n      \n      if (elapsed >= totalDuration) {\n        // Stop everything\n        setFlickerDecay(0);\n        setLetterSharpness(prev => {\n          const newSharpness = { ...prev };\n          visibleLetters.forEach(letterIndex => {\n            newSharpness[letterIndex] = 1;\n          });\n          return newSharpness;\n        });\n        clearInterval(transitionInterval);\n      } else {\n        // Calculate progress\n        const progress = elapsed / totalDuration;\n        \n        // Flicker decay: linear from 1 to 0\n        const newFlickerDecay = Math.max(0, 1 - progress);\n        setFlickerDecay(newFlickerDecay);\n        \n        // Letter sharpness: gradually increase\n        setLetterSharpness(prev => {\n          const newSharpness = { ...prev };\n          visibleLetters.forEach(letterIndex => {\n            if (!newSharpness[letterIndex]) {\n              newSharpness[letterIndex] = 0;\n            }\n            newSharpness[letterIndex] = Math.min(1, newSharpness[letterIndex] + 0.02);\n          });\n          return newSharpness;\n        });\n      }\n    }, 100);\n\n    return () => clearInterval(transitionInterval);\n  }, [visibleLetters, startTime]);\n\n  // Flicker effect with dynamic timing\n  useEffect(() => {\n    if (visibleLetters.length === 0) return;\n\n    // Clear existing interval\n    if (flickerInterval) {\n      clearInterval(flickerInterval);\n    }\n\n    // Create new flicker interval with dynamic timing\n    const createFlickerInterval = () => {\n      const baseInterval = 50; // Base flicker speed\n      const slowInterval = 500; // Slow flicker speed\n      const currentInterval = baseInterval + (1 - flickerDecay) * (slowInterval - baseInterval);\n      \n      const newInterval = setInterval(() => {\n        if (flickerDecay <= 0) {\n          setFlickerIntensity(1); // Stable when no flicker\n        } else {\n          const baseFlicker = Math.random() * 0.5 + 0.5;\n          const adjustedFlicker = baseFlicker * flickerDecay;\n          setFlickerIntensity(adjustedFlicker);\n        }\n      }, currentInterval);\n      \n      setFlickerInterval(newInterval);\n    };\n\n    createFlickerInterval();\n\n    return () => {\n      if (flickerInterval) {\n        clearInterval(flickerInterval);\n      }\n    };\n  }, [visibleLetters.length, flickerDecay]);\n\n  return (\n    <div className=\"App\">\n      <div className=\"misfits-text\">\n        {word.split('').map((letter, index) => {\n          const isVisible = visibleLetters.includes(index);\n          const sharpness = letterSharpness[index] || 0;\n          const blurAmount = isVisible ? (1 - sharpness) * 25 : 25;\n          const opacity = isVisible ? (0.4 + sharpness * 0.6) : 0;\n          const brightness = isVisible ? (0.4 + sharpness * 0.6) : 0.4;\n          \n          return (\n            <span\n              key={index}\n              className={`letter ${isVisible ? 'visible' : ''}`}\n              style={{\n                opacity: opacity,\n                color: neonColors[index % neonColors.length],\n                textShadow: isVisible \n                  ? `0 0 10px ${neonColors[index % neonColors.length]}, 0 0 20px ${neonColors[index % neonColors.length]}, 0 0 30px ${neonColors[index % neonColors.length]}, 0 0 40px ${neonColors[index % neonColors.length]}`\n                  : 'none',\n                transform: isVisible \n                  ? `scale(${1 + (flickerIntensity - 0.7) * 0.03}) translateY(${(flickerIntensity - 0.7) * 1}px)` \n                  : 'scale(0.9) translateY(10px)',\n                filter: `blur(${blurAmount}px) brightness(${brightness})`,\n                transition: 'all 0.3s ease-out'\n              }}\n            >\n              {letter}\n            </span>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n\nexport default App; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}